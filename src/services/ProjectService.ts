// src/services/ProjectService.ts

export interface ProjectConfig {
  name: string;
  template: 'react-ts' | 'vue-ts' | 'nestjs' | 'express-ts';
  language: 'typescript' | 'javascript';
  features: string[];
  author?: string;
  description?: string;
}

export interface GeneratedProject {
  success: boolean;
  projectId: string;
  message: string;
  files: GeneratedFile[];
  downloadUrl?: string;
  commands: string[];
}

export interface GeneratedFile {
  path: string;
  content: string;
  language: string;
}

export class ProjectService {
  // 模拟项目生成
  static async generateProject(config: ProjectConfig): Promise<GeneratedProject> {
    console.log('🚀 开始生成项目:', config);
    
    // 模拟API延迟
    await new Promise(resolve => setTimeout(resolve, 1500));
    
    const projectId = 'project_' + Date.now();
    const files = this.generateProjectFiles(config);
    
    return {
      success: true,
      projectId,
      message: \`项目 "\${config.name}" 生成成功！\`,
      files,
      downloadUrl: \`/api/download/\${projectId}.zip\`,
      commands: [
        \`cd \${config.name}\`,
        'npm install',
        'npm run dev'
      ]
    };
  }
  
  // 生成项目文件结构
  private static generateProjectFiles(config: ProjectConfig): GeneratedFile[] {
    const files: GeneratedFile[] = [];
    
    // package.json
    files.push({
      path: 'package.json',
      content: JSON.stringify(this.generatePackageJson(config), null, 2),
      language: 'json'
    });
    
    // README.md
    files.push({
      path: 'README.md',
      content: \`# \${config.name}\n\n\${config.description || '这是一个使用 MetaCoding 生成的项目'}\n\`,
      language: 'markdown'
    });
    
    // 根据模板生成不同文件
    if (config.template === 'react-ts') {
      files.push(...this.generateReactFiles(config));
    } else if (config.template === 'vue-ts') {
      files.push(...this.generateVueFiles(config));
    } else if (config.template === 'nestjs') {
      files.push(...this.generateNestJSFiles(config));
    }
    
    // .gitignore
    files.push({
      path: '.gitignore',
      content: \`node_modules/\ndist/\n.env\n.DS_Store\n`,
      language: 'gitignore'
    });
    
    return files;
  }
  
  private static generatePackageJson(config: ProjectConfig): any {
    const basePackage = {
      name: config.name,
      version: '1.0.0',
      description: config.description || 'Generated by MetaCoding',
      author: config.author || 'MetaCoding User',
      license: 'MIT',
      scripts: {},
      dependencies: {},
      devDependencies: {}
    };
    
    if (config.template === 'react-ts') {
      basePackage.scripts = {
        dev: 'vite',
        build: 'tsc && vite build',
        preview: 'vite preview',
        lint: 'eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0'
      };
      basePackage.dependencies = {
        react: '^18.2.0',
        'react-dom': '^18.2.0'
      };
      basePackage.devDependencies = {
        '@types/react': '^18.2.43',
        '@types/react-dom': '^18.2.17',
        '@vitejs/plugin-react': '^4.2.1',
        typescript: '^5.2.2',
        vite: '^5.0.8'
      };
    }
    
    return basePackage;
  }
  
  private static generateReactFiles(config: ProjectConfig): GeneratedFile[] {
    return [
      {
        path: 'src/App.tsx',
        content: \`import React from 'react';
import './App.css';

function App() {
  return (
    <div className="App">
      <h1>Welcome to \${config.name}!</h1>
      <p>Generated by MetaCoding 🚀</p>
    </div>
  );
}

export default App;\`,
        language: 'typescript'
      },
      {
        path: 'src/main.tsx',
        content: \`import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);\`,
        language: 'typescript'
      },
      {
        path: 'src/index.css',
        content: \`* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  min-height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
}

#root {
  width: 100%;
}\`,
        language: 'css'
      },
      {
        path: 'tsconfig.json',
        content: \`{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}\`,
        language: 'json'
      },
      {
        path: 'vite.config.ts',
        content: \`import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  server: {
    port: 5173,
    open: true
  }
})\`,
        language: 'typescript'
      }
    ];
  }
  
  private static generateVueFiles(config: ProjectConfig): GeneratedFile[] {
    // Vue项目文件...
    return [];
  }
  
  private static generateNestJSFiles(config: ProjectConfig): GeneratedFile[] {
    // NestJS项目文件...
    return [];
  }
  
  // 下载项目为ZIP文件
  static async downloadProject(project: GeneratedProject): Promise<void> {
    console.log('📥 下载项目:', project.projectId);
    
    // 创建虚拟下载
    const zipContent = JSON.stringify(project.files, null, 2);
    const blob = new Blob([zipContent], { type: 'application/zip' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = \`\${project.projectId}.json\`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    console.log('✅ 下载完成');
  }
  
  // 复制到剪贴板
  static async copyToClipboard(text: string): Promise<void> {
    try {
      await navigator.clipboard.writeText(text);
      console.log('📋 已复制到剪贴板');
    } catch (err) {
      console.error('复制失败:', err);
      // 备用方法
      const textArea = document.createElement('textarea');
      textArea.value = text;
      document.body.appendChild(textArea);
      textArea.select();
      document.execCommand('copy');
      document.body.removeChild(textArea);
    }
  }
}
